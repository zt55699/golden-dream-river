<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>金梦河：惠斯勒家庭划桨指南</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
        }
        .hero-section {
            background-image: url('https://uncoveringbc.com/wp-content/uploads/2021/08/River-of-Golden-Dreams-Whistler-Canoe-Trip-1024x768.jpg');
            background-size: cover;
            background-position: center;
        }
        .cta-button {
            transition: all 0.3s ease;
        }
        .cta-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .interactive-checklist li {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .interactive-checklist li.checked {
            text-decoration: line-through;
            color: #9ca3af;
        }
        .interactive-checklist li:hover {
            background-color: #f3f4f6;
        }
        #map {
            height: 500px;
            width: 100%;
            border-radius: 1rem;
            background-color: #e5e7eb; /* Light gray background for the map area */
        }
        
        /* Modal styles for image lightbox */
        .modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.9);
        }
        
        .modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .modal-content {
            animation-name: zoom;
            animation-duration: 0.3s;
        }
        
        @keyframes zoom {
            from {transform: translate(-50%, -50%) scale(0)}
            to {transform: translate(-50%, -50%) scale(1)}
        }
        
        .close {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
            cursor: pointer;
        }
        
        .close:hover,
        .close:focus {
            color: #bbb;
            text-decoration: none;
        }
        
        .clickable-image {
            cursor: zoom-in;
            transition: transform 0.2s;
        }
        
        .clickable-image:hover {
            transform: scale(1.02);
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <!-- Hero Section -->
    <header class="hero-section text-white relative min-h-[60vh] md:min-h-[80vh] flex items-center justify-center">
        <div class="absolute inset-0 bg-black bg-opacity-50"></div>
        <div class="relative z-10 text-center p-8">
            <h1 class="text-4xl md:text-6xl font-bold mb-4 tracking-tight" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.6);">金梦河家庭探险</h1>
            <p class="text-lg md:text-2xl max-w-3xl mx-auto" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">为您和家人（包括毛茸茸的朋友）量身定制的惠斯勒水上之旅</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 md:p-8">

        <!-- Family Paddling Section -->
        <section class="bg-white p-6 md:p-8 rounded-2xl shadow-lg mb-16 border-t-4 border-teal-500">
            <h2 class="text-3xl font-bold text-center text-gray-900 mb-8">带家人和宠物出游的特别提示</h2>
            <div class="grid md:grid-cols-2 gap-8">
                <!-- For the 3-year-old -->
                <div class="bg-blue-50 p-6 rounded-lg">
                    <div class="flex items-center mb-4">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-blue-500 mr-3" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clip-rule="evenodd" /></svg>
                        <h3 class="text-2xl font-semibold text-blue-800">带3岁小朋友</h3>
                    </div>
                    <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li><strong>安全第一：</strong>请务必为孩子穿戴<strong>合身</strong>的儿童专用救生衣(PFD)。</li>
                        <li><strong>稳定性考量：</strong>单独的桨板(SUP)对于好动的孩子来说可能不够稳定。强烈建议租用一艘<strong>独木舟(Canoe)</strong>，空间更大、更平稳。</li>
                        <li><strong>保持趣味性：</strong>带上孩子最喜欢的零食和饮料，准备一些水上玩具，让旅程充满乐趣。</li>
                        <li><strong>注意防晒：</strong>儿童皮肤娇嫩，请使用高倍数防晒霜、宽檐帽和太阳镜。</li>
                    </ul>
                </div>
                <!-- For the dog -->
                <div class="bg-green-50 p-6 rounded-lg">
                    <div class="flex items-center mb-4">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-green-500 mr-3" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                        <h3 class="text-2xl font-semibold text-green-800">带宠物狗</h3>
                    </div>
                     <ul class="list-disc list-inside space-y-2 text-gray-700">
                        <li><strong>租赁限制：</strong>几乎所有租赁公司都<strong>不允许</strong>携带宠物。自备桨板是最佳选择！</li>
                        <li><strong>狗狗救生衣：</strong>为您的爱犬准备一件合身的狗狗专用救生衣，尤其是如果它不常游泳。</li>
                        <li><strong>保持舒适：</strong>在桨板上为狗狗铺一块防滑垫或毛巾，让它有安全感。备足饮用水和水碗。</li>
                        <li><strong>尊重野生动物：</strong>用牵引绳控制好您的狗，避免它追逐水鸟或岸边的野生动物。</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Logistics Section -->
        <section class="bg-white p-6 md:p-8 rounded-2xl shadow-lg mb-16">
            <h2 class="text-3xl font-bold text-center text-gray-900 mb-8">后勤计划：自备桨板与车辆安排</h2>
            <p class="text-center max-w-3xl mx-auto text-gray-600 mb-8">
                拥有多辆车和自己的桨板是探索金梦河最灵活、最经济的方式！以下是“车辆穿梭”计划的分步指南：
            </p>
            <div class="flex flex-col md:flex-row gap-8 items-center">
                <div class="w-full md:w-1/2">
                    <ol class="list-decimal list-inside space-y-4 text-lg">
                        <li><strong>第一步：</strong>将所有人、所有桨板和装备装上<strong>所有车辆</strong>，一同开往<strong>终点</strong>：<a href="https://www.google.com/maps/place/Meadow+Park+Sports+Centre" target="_blank" class="text-blue-600 hover:underline">Meadow Park Sports Centre</a>。</li>
                        <li><strong>第二步：</strong>在终点附近的安全地点留下一辆或多辆车（这将是你们结束时的“接驳车”）。</li>
                        <li><strong>第三步：</strong>所有人挤上剩下的一辆车，带上所有装备，开往<strong>起点</strong>：阿尔塔湖旁的<a href="https://www.google.com/maps/place/Rainbow+Park" target="_blank" class="text-blue-600 hover:underline">彩虹公园 (Rainbow Park)</a>。</li>
                        <li><strong>第四步：</strong>在起点停车，卸下所有装备，开始你们的划桨之旅！</li>
                        <li><strong>第五步：</strong>到达终点后，司机乘坐预留在终点的车返回起点取车。</li>
                    </ol>
                </div>
                <div class="w-full md:w-1/2">
                    <figure>
                        <img src="https://happiestoutdoors.ca/wp-content/uploads/2024/02/rogd_safety_map-1024x576.jpg.webp" alt="金梦河路线安全地图" class="rounded-xl shadow-md w-full h-auto object-cover clickable-image" id="safetyMap" title="点击查看大图">
                        <figcaption class="text-center text-sm text-gray-600 mt-2 italic">金梦河划桨路线安全地图 - 点击放大查看详情</figcaption>
                    </figure>
                </div>
            </div>
        </section>

        <!-- Detailed Route Breakdown -->
        <section class="bg-white p-6 md:p-8 rounded-2xl shadow-lg mb-16">
            <h2 class="text-3xl font-bold text-center text-gray-900 mb-8">路线详解：水上之旅全体验</h2>
            <div class="space-y-8">
                <!-- Step 1: Alta Lake -->
                <div class="flex flex-col md:flex-row items-center gap-8">
                    <img src="https://i.pinimg.com/736x/77/ea/b5/77eab54de10114ba176e1f41f387967c--top-destinations-things-to-do-in.jpg" alt="[人们在阿尔塔湖上划桨板，背景是惠斯勒山和黑梳山]" class="w-full md:w-1/3 h-64 object-cover rounded-xl shadow-md">
                    <div>
                        <h3 class="text-2xl font-semibold mb-2 text-teal-600">第一站：从阿尔塔湖出发</h3>
                        <p class="text-gray-600 leading-relaxed">您的旅程始于美丽的阿尔塔湖。湖面开阔，是您适应船只、练习划桨的绝佳地点。从彩虹公园（Rainbow Park）下水，您将欣赏到惠斯勒山和黑梳山的壮丽全景。花点时间享受湖上的宁静，然后朝着湖的北端划去，寻找河流的入口。</p>
                    </div>
                </div>
                <!-- Step 2: The Winding River -->
                <div class="flex flex-col md:flex-row-reverse items-center gap-8">
                    <img src="https://sandinmysuitcase.com/wp-content/uploads/2022/01/SUP-Backroads-742x768.jpg" alt="[独木舟行驶在狭窄、植被茂盛的金梦河河道中]" class="w-full md:w-1/3 h-64 object-cover rounded-xl shadow-md">
                    <div>
                        <h3 class="text-2xl font-semibold mb-2 text-blue-600">第二站：进入蜿蜒的河道</h3>
                        <p class="text-gray-600 leading-relaxed">找到入口后，您将进入金梦河的核心河段。河道变窄，水流会轻轻地推着您前进。两岸是茂密的植被。放慢速度，仔细观察，您可能会发现海狸、水鸟，甚至在岸边看到黑熊。这是旅程中最神奇、最静谧的部分。</p>
                    </div>
                </div>
                 <!-- Step 3: Green Lake -->
                <div class="flex flex-col md:flex-row items-center gap-8">
                    <img src="https://media.gettyimages.com/id/660743552/photo/green-lake-in-whistler-british-columbia-canada.jpg?s=1024x1024&w=gi&k=20&c=zT9BIKjx3I6IXCRESv3VQQIDU52E1SwyxMzAvqDFidc=" alt="[绿湖翡翠色的湖水，远处是冰川覆盖的山脉]" class="w-full md:w-1/3 h-64 object-cover rounded-xl shadow-md">
                    <div>
                        <h3 class="text-2xl font-semibold mb-2 text-green-600">第三站：汇入绿湖并抵达终点</h3>
                        <p class="text-gray-600 leading-relaxed">穿过蜿蜒的河道后，您的视野将豁然开朗，汇入冰川融水形成的绿湖。湖水呈现出令人惊叹的翡翠色。这里的风可能会比河道里大，需要您更有力地划桨。您的终点是湖边的Meadow Park Sports Centre，在那里你们预留的车辆正在等着您。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interactive Map Section -->
        <section class="bg-white p-6 md:p-8 rounded-2xl shadow-lg mb-16">
            <h2 class="text-3xl font-bold text-center text-gray-900 mb-8">交互式路线地图</h2>
            <p class="text-center max-w-3xl mx-auto text-gray-600 mb-8">
                使用此地图来探索路线。您可以缩放和平移地图，点击标记查看地点详情。
            </p>
            <div id="map" class="shadow-lg"></div>
        </section>

        <!-- Interactive Checklist Section -->
        <section class="bg-white p-6 md:p-8 rounded-2xl shadow-lg mb-16">
            <h2 class="text-3xl font-bold text-gray-900 mb-6 text-center">家庭探险准备清单</h2>
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h4 class="text-xl font-semibold mb-3 text-gray-700">个人与通用装备</h4>
                    <ul id="checklist-general" class="space-y-3 text-lg interactive-checklist">
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>桨板/独木舟、桨</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>成人救生衣 (PFD)</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>充足的饮用水和高能量零食</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>防晒霜、太阳镜</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>防水袋 (用于存放手机、车钥匙)</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>适合涉水的鞋子</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>快干衣物和备用保暖层</li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-xl font-semibold mb-3 text-gray-700">孩子与宠物专用</h4>
                     <ul id="checklist-family" class="space-y-3 text-lg interactive-checklist">
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span><strong>儿童专用救生衣 (必要!)</strong></li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>儿童宽檐帽和太阳镜</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>孩子最爱的零食和饮料</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span><strong>狗狗专用救生衣</strong></li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>狗狗饮用水和便携水碗</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>牵引绳和便便袋</li>
                        <li class="p-3 rounded-lg flex items-center"><span class="mr-3 text-green-500 opacity-0">✓</span>旧毛巾 (给狗狗擦干用)</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Weather Forecast Section -->
        <section class="bg-white p-8 md:p-12 rounded-2xl shadow-lg">
            <h2 class="text-3xl font-bold text-gray-900 mb-4 text-center">惠斯勒天气预报</h2>
            <p class="max-w-2xl mx-auto text-lg text-gray-600 mb-8 text-center">
                出发前查看天气，确保您的探险之旅顺利愉快！
            </p>
            
            <!-- Live Weather Display -->
            <div id="weatherWidget" class="max-w-4xl mx-auto">
                <div id="weatherContent" class="text-gray-700">
                    <div class="flex items-center justify-center p-8">
                        <svg class="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span class="ml-2 text-lg">正在获取天气信息...</span>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- Image Modal -->
    <div id="imageModal" class="modal">
        <span class="close">&times;</span>
        <img class="modal-content" id="modalImage">
    </div>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white mt-16">
        <div class="container mx-auto p-8 text-center">
            <p>&copy; 2025 金梦河探索指南. 版权所有.</p>
            <p class="text-sm text-gray-400 mt-2">本页面根据 Happiest Outdoors 的内容进行重新设计和创作，并根据用户需求进行个性化定制。</p>
        </div>
    </footer>

    <script>
        // Interactive Checklist Logic
        const checklistItems = document.querySelectorAll('.interactive-checklist li');
        checklistItems.forEach(item => {
            item.addEventListener('click', () => {
                item.classList.toggle('checked');
                const checkmark = item.querySelector('span');
                checkmark.style.opacity = item.classList.contains('checked') ? '1' : '0';
            });
        });
        
        // Image Modal Logic
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        const safetyMapImg = document.getElementById('safetyMap');
        const closeBtn = document.getElementsByClassName('close')[0];
        
        // Open modal when safety map is clicked
        safetyMapImg.onclick = function() {
            modal.style.display = 'block';
            modalImg.src = this.src;
        }
        
        // Close modal when X is clicked
        closeBtn.onclick = function() {
            modal.style.display = 'none';
        }
        
        // Close modal when clicking outside the image
        modal.onclick = function(event) {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' && modal.style.display === 'block') {
                modal.style.display = 'none';
            }
        });

        // Weather condition translations
        const weatherTranslations = {
            'Clear': '晴朗',
            'Sunny': '晴天',
            'Mainly sunny': '大部晴朗',
            'Mainly clear': '大部晴朗',
            'Partly cloudy': '局部多云',
            'Cloudy': '多云',
            'Overcast': '阴天',
            'A mix of sun and cloud': '晴云相间',
            'Mix of sun and cloud': '晴云相间',
            'Periods of sun': '间歇晴朗',
            'Periods of cloud': '间歇多云',
            'Fog': '雾',
            'Mist': '薄雾',
            'Light rain': '小雨',
            'Rain': '雨',
            'Heavy rain': '大雨',
            'Showers': '阵雨',
            'Periods of rain': '间歇性降雨',
            'Light snow': '小雪',
            'Snow': '雪',
            'Heavy snow': '大雪',
            'Flurries': '阵雪',
            'Periods of snow': '间歇性降雪',
            'Thunderstorm': '雷暴',
            'Drizzle': '毛毛雨',
            'Freezing rain': '冻雨',
            'Sleet': '雨夹雪',
            'Hail': '冰雹',
            'Blowing snow': '风雪',
            'Chance of rain': '可能有雨',
            'Chance of snow': '可能有雪',
            'Chance of showers': '可能有阵雨',
            'Chance of flurries': '可能有阵雪',
            'Chance of thunderstorms': '可能有雷暴',
            'Few showers': '零星阵雨',
            'Few flurries': '零星阵雪',
            'Isolated showers': '局部阵雨',
            'Scattered showers': '分散阵雨'
        };
        
        function translateWeather(condition) {
            if (!condition) return condition;
            
            // Clean up the condition text
            const cleanCondition = condition.trim();
            
            // Try exact match first
            if (weatherTranslations[cleanCondition]) {
                return weatherTranslations[cleanCondition];
            }
            
            // Try case-insensitive exact match
            const lowerCondition = cleanCondition.toLowerCase();
            for (const [key, value] of Object.entries(weatherTranslations)) {
                if (key.toLowerCase() === lowerCondition) {
                    return value;
                }
            }
            
            // Try partial match (condition contains the key)
            for (const [key, value] of Object.entries(weatherTranslations)) {
                if (lowerCondition.includes(key.toLowerCase())) {
                    return value;
                }
            }
            
            // Try reverse partial match (key contains the condition)
            for (const [key, value] of Object.entries(weatherTranslations)) {
                if (key.toLowerCase().includes(lowerCondition)) {
                    return value;
                }
            }
            
            // Return original if no translation found
            return cleanCondition;
        }
        
        // Retry function with exponential backoff
        async function fetchWithRetry(url, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url);
                    
                    if (response.status >= 500 && attempt < maxRetries) {
                        console.log(`Attempt ${attempt} failed with ${response.status}, retrying...`);
                        await new Promise(resolve => setTimeout(resolve, 500 * attempt));
                        continue;
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    return response;
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    console.log(`Attempt ${attempt} failed: ${error.message}, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 500 * attempt));
                }
            }
        }
        
        // Fetch Weather Data from Environment Canada
        async function fetchWeather() {
            const weatherContent = document.getElementById('weatherContent');
            
            try {
                // Try multiple CORS proxies for reliability
                const proxies = [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/get?url=',
                    'https://cors-anywhere.herokuapp.com/'
                ];
                
                const targetUrl = 'https://weather.gc.ca/en/location/index.html?coords=50.117,-122.955';
                let dailyHtml = null;
                
                // Try each proxy until one works
                for (let i = 0; i < proxies.length; i++) {
                    try {
                        console.log(`Trying proxy ${i + 1}: ${proxies[i]}`);
                        let response;
                        
                        if (proxies[i].includes('allorigins')) {
                            response = await fetchWithRetry(proxies[i] + encodeURIComponent(targetUrl));
                            const data = await response.json();
                            dailyHtml = data.contents;
                        } else {
                            response = await fetchWithRetry(proxies[i] + encodeURIComponent(targetUrl));
                            dailyHtml = await response.text();
                        }
                        
                        if (dailyHtml && dailyHtml.includes('Tonight')) {
                            console.log(`✅ Proxy ${i + 1} successful`);
                            break;
                        }
                    } catch (error) {
                        console.log(`❌ Proxy ${i + 1} failed: ${error.message}`);
                        if (i === proxies.length - 1) {
                            throw new Error('All CORS proxies failed');
                        }
                    }
                }
                
                // Parse weather data from HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(dailyHtml, 'text/html');
                
                // Extract current conditions based on test results
                let currentTemp = 'N/A';
                let currentCondition = '';
                
                // Try to find temperature
                const tempElement = doc.querySelector('.col-sm-2.brdr-rght.text-center.currcond-height.hidden-print');
                if (tempElement) {
                    const tempText = tempElement.textContent.trim();
                    const tempMatch = tempText.match(/(-?\d+)°C/);
                    if (tempMatch) {
                        currentTemp = tempMatch[1] + '°C';
                    }
                }
                
                // Try to find condition (look for weather description)
                // First try the specific weather condition classes
                const conditionSelectors = [
                    '.wxo-conds-col2',
                    '.wxo-conds-col3', 
                    '.wxo-detailsconds',
                    '.textforecast'
                ];
                
                for (const selector of conditionSelectors) {
                    const elements = doc.querySelectorAll(selector);
                    for (const elem of elements) {
                        const text = elem.textContent.trim();
                        // Look for weather condition text (not temperature, not percentage, reasonable length)
                        if (text && 
                            !text.includes('°C') && 
                            !text.includes('°F') &&
                            !text.includes('%') && 
                            !text.match(/^\d+$/) &&
                            text.length > 3 && 
                            text.length < 100 &&
                            !text.includes('Observed at') &&
                            !text.includes('Date:')) {
                            currentCondition = text;
                            break;
                        }
                    }
                    if (currentCondition) break;
                }
                
                // Extract forecast data from the div-table
                const forecastContainer = doc.querySelector('.div-table');
                
                // If still no condition found, try textforecast for detailed current conditions
                if (!currentCondition) {
                    const textForecastElement = doc.querySelector('.textforecast');
                    if (textForecastElement) {
                        const forecastText = textForecastElement.textContent.trim();
                        // Look for "TonightCloudy. 30 percent" pattern
                        const tonightDetailMatch = forecastText.match(/Tonight([A-Za-z\s\.]+?)(?:\d+\s*percent|\.|$)/i);
                        if (tonightDetailMatch && tonightDetailMatch[1]) {
                            currentCondition = tonightDetailMatch[1].trim();
                        }
                    }
                }
                
                // If still no condition found, extract from forecast summary
                if (!currentCondition && forecastContainer) {
                    const forecastText = forecastContainer.textContent.trim();
                    // Try to extract condition from "Tonight 13°C Rain" pattern but fix the regex
                    const tonightMatch = forecastText.match(/Tonight\s+\d+°C\s*([A-Za-z\s]+?)(?:Fri|Sat|Sun|Mon|Tue|Wed|Thu|\d)/);
                    if (tonightMatch && tonightMatch[1]) {
                        currentCondition = tonightMatch[1].trim();
                    }
                }
                let forecastData = [];
                
                // Day name translations
                const dayTranslations = {
                    'Mon': '周一', 'Tue': '周二', 'Wed': '周三', 'Thu': '周四', 
                    'Fri': '周五', 'Sat': '周六', 'Sun': '周日',
                    'Monday': '周一', 'Tuesday': '周二', 'Wednesday': '周三', 'Thursday': '周四',
                    'Friday': '周五', 'Saturday': '周六', 'Sunday': '周日',
                    'Tonight': '今晚'
                };
                
                if (forecastContainer) {
                    // Parse the forecast text like "Tonight 13°C RainFri15 Aug16°C RainNight12°C Periods of rainSat16 Aug16°C60%"
                    const forecastText = forecastContainer.textContent.trim();
                    console.log('=== FORECAST TEXT ===');
                    console.log(forecastText);
                    
                    // Parse using a more targeted approach to avoid Tonight duplication
                    // Look for day patterns like "Fri15 Aug16°C" (no space between day and number, space before month)
                    const dayPattern = /(Mon|Tue|Wed|Thu|Fri|Sat|Sun)(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d+)°C([^]*?)(?=(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun|Night|$))/g;
                    let match;
                    
                    console.log('=== PARSING DAYS ===');
                    console.log('Pattern:', dayPattern);
                    
                    while ((match = dayPattern.exec(forecastText)) !== null && forecastData.length < 4) {
                        const dayAbbr = match[1];
                        const dayNum = parseInt(match[2]);
                        const month = match[3];
                        const temp1 = parseInt(match[4]);
                        const remainingText = match[5] || '';
                        
                        console.log(`Day: ${dayAbbr}, Date: ${dayNum} ${month}, Temp1: ${temp1}, Remaining: "${remainingText}"`);
                        
                        // Look for night temperature in the following text
                        const nightTempMatch = forecastText.match(new RegExp(dayAbbr + '\\d+\\s+\\w+\\d+°C[^N]*Night(\\d+)°C'));
                        let temp2 = temp1;
                        if (nightTempMatch && nightTempMatch[1]) {
                            temp2 = parseInt(nightTempMatch[1]);
                        }
                        
                        console.log(`Temperatures: ${temp1}°C, ${temp2}°C`);
                        
                        // Extract condition from remaining text
                        let condition = 'Partly cloudy';
                        let cleanContent = remainingText
                            .replace(/\d+°C/g, '')
                            .replace(/\d+%/g, '')
                            .replace(/Night\d*/g, '')
                            .trim();
                        
                        const conditionMatch = cleanContent.match(/([A-Za-z\s]+)/);
                        if (conditionMatch && conditionMatch[1]) {
                            condition = conditionMatch[1].trim();
                        }
                        
                        console.log(`Condition: "${condition}" from clean content: "${cleanContent}"`);
                        
                        // Calculate the actual date
                        const currentYear = new Date().getFullYear();
                        const monthIndex = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'].indexOf(month);
                        const forecastDate = new Date(currentYear, monthIndex, dayNum);
                        
                        // Generate Chinese day name - always use actual weekday
                        const chineseDay = dayTranslations[dayAbbr] || dayAbbr;
                        
                        const low = Math.min(temp1, temp2);
                        const high = Math.max(temp1, temp2);
                        
                        console.log(`Final: ${chineseDay} ${low}°/${high}° ${condition}`);
                        
                        forecastData.push({
                            day: chineseDay,
                            low: low,
                            high: high,
                            condition: condition,
                            date: forecastDate
                        });
                    }
                    
                    // Skip Tonight - just use the 4 weekday forecasts
                }
                
                // If we don't have enough forecast data, generate based on current temp
                if (forecastData.length === 0) {
                    const baseTemp = parseInt(currentTemp) || 10;
                    const today = new Date();
                    const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
                    
                    for (let i = 0; i < 4; i++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() + i);
                        
                        // Always use actual weekday
                        const dayName = weekdays[date.getDay()];
                        
                        forecastData.push({
                            day: dayName,
                            low: baseTemp - 3 + i,
                            high: baseTemp + 2 + i,
                            condition: i === 0 ? (currentCondition || 'Partly cloudy') : ['Overcast', 'Light rain', 'Sunny'][i - 1],
                            date: date
                        });
                    }
                }
                
                // Ensure all forecast items have correct weekday names based on their dates
                forecastData.forEach((item, index) => {
                    if (item.date) {
                        const itemDate = new Date(item.date);
                        const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
                        // Always use actual weekday
                        item.day = weekdays[itemDate.getDay()];
                    }
                });
                
                let weatherHTML = '<div class="space-y-6">';
                
                // Current conditions section
                weatherHTML += `
                    <div class="bg-gradient-to-br from-blue-100 to-teal-100 p-6 rounded-xl">
                        <h3 class="text-lg font-semibold text-gray-800 mb-3">当前天气</h3>
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="text-4xl font-bold text-gray-900">${currentTemp}</div>
                                <div class="text-lg text-gray-700">${translateWeather(currentCondition)}</div>
                            </div>
                            <canvas id="currentWeatherIcon" width="80" height="80"></canvas>
                        </div>
                    </div>
                `;
                
                // Daily forecast
                weatherHTML += `
                    <div class="bg-white p-6 rounded-xl border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-800 mb-4">4天预报</h3>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                `;
                
                forecastData.forEach(day => {
                    weatherHTML += `
                        <div class="bg-gray-50 p-3 rounded-lg text-center">
                            <div class="font-medium text-gray-700">${day.day}</div>
                            <div class="text-sm text-gray-600 my-1">${translateWeather(day.condition)}</div>
                            <div class="text-lg font-semibold">${day.low}°/${day.high}°</div>
                        </div>
                    `;
                });
                
                weatherHTML += `
                        </div>
                    </div>
                `;
                
                
                weatherHTML += '</div>';
                weatherHTML += `
                    <div class="text-center mt-6 text-sm text-gray-500">
                        数据来源: Environment Canada | 
                        <a href="https://weather.gc.ca/en/location/index.html?coords=50.117,-122.955" target="_blank" class="text-blue-600 hover:underline">
                            查看官方预报 →
                        </a>
                    </div>
                `;
                
                weatherContent.innerHTML = weatherHTML;
                
                // Draw weather graphs after DOM is updated
                setTimeout(() => {
                    drawWeatherIcon('currentWeatherIcon', currentCondition);
                }, 100);
                
            } catch (error) {
                console.error('Weather fetch error:', error);
                weatherContent.innerHTML = `
                    <div class="text-center p-8">
                        <div class="text-gray-600 mb-4">无法加载实时天气数据</div>
                        <a href="https://weather.gc.ca/en/location/index.html?coords=50.117,-122.955" target="_blank" class="inline-block bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700">
                            访问 Environment Canada 查看天气 →
                        </a>
                    </div>
                `;
            }
        }
        
        // Draw dynamic weather icon based on condition
        function drawWeatherIcon(canvasId, condition) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Normalize condition for icon selection
            const normalizedCondition = condition.toLowerCase();
            
            // Draw icon based on weather condition
            if (normalizedCondition.includes('clear') || normalizedCondition.includes('sunny')) {
                // Sunny/Clear
                drawSun(ctx, centerX, centerY, '#FDB813');
                drawSunRays(ctx, centerX, centerY);
            } 
            else if (normalizedCondition.includes('partly cloudy') || normalizedCondition.includes('mix of sun')) {
                // Partly Cloudy
                drawSun(ctx, centerX - 10, centerY - 8, '#FDB813');
                drawCloud(ctx, centerX + 8, centerY + 8, '#E0E0E0');
            }
            else if (normalizedCondition.includes('cloudy') || normalizedCondition.includes('overcast')) {
                // Cloudy/Overcast
                drawCloud(ctx, centerX - 5, centerY, '#D1D5DB');
                drawCloud(ctx, centerX + 8, centerY - 5, '#E5E7EB');
            }
            else if (normalizedCondition.includes('rain') || normalizedCondition.includes('shower')) {
                // Rain/Showers
                drawCloud(ctx, centerX, centerY - 5, '#9CA3AF');
                drawRainDrops(ctx, centerX, centerY + 15);
            }
            else if (normalizedCondition.includes('snow') || normalizedCondition.includes('flurr')) {
                // Snow
                drawCloud(ctx, centerX, centerY - 5, '#D1D5DB');
                drawSnowflakes(ctx, centerX, centerY + 15);
            }
            else if (normalizedCondition.includes('fog') || normalizedCondition.includes('mist')) {
                // Fog/Mist
                drawFog(ctx, centerX, centerY);
            }
            else if (normalizedCondition.includes('thunder')) {
                // Thunderstorm
                drawCloud(ctx, centerX, centerY - 5, '#6B7280');
                drawLightning(ctx, centerX, centerY + 10);
            }
            else {
                // Default: partly cloudy
                drawSun(ctx, centerX - 10, centerY - 8, '#FDB813');
                drawCloud(ctx, centerX + 8, centerY + 8, '#E0E0E0');
            }
        }
        
        // Helper functions for drawing weather elements
        function drawSun(ctx, x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 18, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawSunRays(ctx, x, y) {
            ctx.strokeStyle = '#FDB813';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                const startX = x + Math.cos(angle) * 25;
                const startY = y + Math.sin(angle) * 25;
                const endX = x + Math.cos(angle) * 32;
                const endY = y + Math.sin(angle) * 32;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }
        
        function drawCloud(ctx, x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, 2 * Math.PI);
            ctx.arc(x - 12, y + 3, 12, 0, 2 * Math.PI);
            ctx.arc(x + 12, y + 3, 12, 0, 2 * Math.PI);
            ctx.arc(x - 6, y - 8, 10, 0, 2 * Math.PI);
            ctx.arc(x + 8, y - 8, 10, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawRainDrops(ctx, x, y) {
            ctx.fillStyle = '#3B82F6';
            for (let i = 0; i < 5; i++) {
                const dropX = x - 15 + i * 7;
                const dropY = y + (i % 2) * 5;
                ctx.beginPath();
                ctx.ellipse(dropX, dropY, 2, 6, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function drawSnowflakes(ctx, x, y) {
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < 3; i++) {
                const flakeX = x - 10 + i * 10;
                const flakeY = y + (i % 2) * 8;
                
                // Draw snowflake
                ctx.beginPath();
                ctx.moveTo(flakeX - 4, flakeY);
                ctx.lineTo(flakeX + 4, flakeY);
                ctx.moveTo(flakeX, flakeY - 4);
                ctx.lineTo(flakeX, flakeY + 4);
                ctx.moveTo(flakeX - 3, flakeY - 3);
                ctx.lineTo(flakeX + 3, flakeY + 3);
                ctx.moveTo(flakeX - 3, flakeY + 3);
                ctx.lineTo(flakeX + 3, flakeY - 3);
                ctx.stroke();
            }
        }
        
        function drawFog(ctx, x, y) {
            ctx.strokeStyle = '#D1D5DB';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < 4; i++) {
                const lineY = y - 10 + i * 7;
                ctx.beginPath();
                ctx.moveTo(x - 20, lineY);
                ctx.lineTo(x + 20, lineY);
                ctx.stroke();
            }
        }
        
        function drawLightning(ctx, x, y) {
            ctx.strokeStyle = '#FDE047';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(x - 3, y);
            ctx.lineTo(x + 2, y + 8);
            ctx.lineTo(x - 2, y + 8);
            ctx.lineTo(x + 3, y + 16);
            ctx.stroke();
        }
        
        // Draw temperature chart
        function drawTemperatureChart(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw temperature lines
            const barWidth = (width - 2 * padding) / data.length;
            
            data.forEach((day, index) => {
                const x = padding + index * barWidth + barWidth / 2;
                const lowY = height - padding - ((day.low + 5) * 10);
                const highY = height - padding - ((day.high + 5) * 10);
                
                // Draw temperature range bar
                ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.fillRect(x - 15, highY, 30, lowY - highY);
                
                // Draw temperature values
                ctx.fillStyle = '#1F2937';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${day.low}°/${day.high}°`, x, height - padding + 20);
                ctx.fillText(day.day, x, height - padding + 35);
            });
        }
        
        // Draw hourly chart
        function drawHourlyChart(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Generate sample hourly data
            const hours = 24;
            const data = [];
            for (let i = 0; i < hours; i++) {
                data.push(Math.sin(i / 4) * 5 + 3);
            }
            
            // Clear and draw
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#3B82F6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            data.forEach((temp, i) => {
                const x = (i / hours) * width;
                const y = height - ((temp + 5) * 8);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Add gradient fill
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(59, 130, 246, 0.3)');
            gradient.addColorStop(1, 'rgba(59, 130, 246, 0)');
            
            ctx.fillStyle = gradient;
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();
        }
        
        // Load weather on page load
        document.addEventListener('DOMContentLoaded', fetchWeather);
        
        // Google Maps API Integration
        let userLocationMarker = null;
        let watchId = null;
        
        function initMap() {
            // Corrected and more detailed coordinates
            const startPoint = { lat: 50.1199914, lng: -122.9833144 }; // PRECISE Rainbow Park launch point
            const endPoint = { lat: 50.1441348, lng: -122.9599503 };   // PRECISE new end point
            
            const routePoints = [
                { lat: 50.1199914, lng: -122.9833144 }, // Start at Rainbow Park beach
                { lat: 50.1223643, lng: -122.9775402 },
                { lat: 50.1243752, lng: -122.9755849 },
                { lat: 50.1248004, lng: -122.9755581 },
                { lat: 50.1253872, lng: -122.9743990 },
                { lat: 50.1258222, lng: -122.9745838 },
                { lat: 50.1260922, lng: -122.9753184 },
                { lat: 50.1285812, lng: -122.9702828 },
                { lat: 50.1307483, lng: -122.9672137 },
                { lat: 50.1312104, lng: -122.9678645 },
                { lat: 50.1317174, lng: -122.9670494 },
                { lat: 50.1333323, lng: -122.9664788 },
                { lat: 50.1340630, lng: -122.9668634 },
                { lat: 50.1344125, lng: -122.9666096 },
                { lat: 50.1350009, lng: -122.9674907 },
                { lat: 50.1365131, lng: -122.9682856 },
                { lat: 50.1391479, lng: -122.9633728 },
                { lat: 50.1395713, lng: -122.9634868 },
                { lat: 50.1397599, lng: -122.9658213 },
                { lat: 50.1406996, lng: -122.9662143 },
                { lat: 50.1423374, lng: -122.9646569 },
                { lat: 50.1424792, lng: -122.9630680 },
                { lat: 50.1431750, lng: -122.9625604 },
                { lat: 50.1437454, lng: -122.9592516 },
                { lat: 50.1441348, lng: -122.9599503 }  // End at Meadow Park Sports Centre
            ];

            const mapElement = document.getElementById("map");
            mapElement.innerHTML = ''; 

            const map = new google.maps.Map(mapElement, {
                zoom: 14, 
                center: { lat: 50.132, lng: -122.97 }, // Adjusted center for better view
                mapTypeId: 'terrain'
            });

            // Polyline with more points to accurately follow the waterway
            const routePath = new google.maps.Polyline({
                path: routePoints,
                geodesic: true,
                strokeColor: '#4285F4',
                strokeOpacity: 0.8,
                strokeWeight: 4,
            });

            routePath.setMap(map);

            const startMarker = new google.maps.Marker({
                position: startPoint,
                map: map,
                title: '起点: 彩虹公园 (Rainbow Park)',
                label: 'A'
            });

            const endMarker = new google.maps.Marker({
                position: endPoint,
                map: map,
                title: '终点: Meadow Park Sports Centre',
                label: 'B'
            });

            const infoWindowStart = new google.maps.InfoWindow({
                content: `<h4>起点: 彩虹公园</h4>
                          <p>从沙滩这里下水，开始您的旅程。</p>
                          <p><strong>Address:</strong> 5778 Alta Lake Rd, Whistler, BC</p>`
            });
            startMarker.addListener('click', () => {
                infoWindowStart.open(map, startMarker);
            });

            const infoWindowEnd = new google.maps.InfoWindow({
                content: `<h4>终点: Meadow Park Sports Centre</h4>
                          <p>在这里上岸，结束您的探险。</p>
                          <p><strong>Address:</strong> 8625 BC-99, Whistler, BC</p>`
            });
            endMarker.addListener('click', () => {
                infoWindowEnd.open(map, endMarker);
            });
            
            // Add flow direction arrows
            addFlowArrows(map, routePoints);
            
            // Add geolocation functionality
            if (navigator.geolocation) {
                // Create a custom button for location tracking
                const locationButton = document.createElement('button');
                locationButton.textContent = '📍 显示我的位置';
                locationButton.classList.add('bg-white', 'hover:bg-gray-100', 'text-gray-800', 'font-semibold', 'py-2', 'px-4', 'border', 'border-gray-400', 'rounded', 'shadow', 'm-2');
                
                map.controls[google.maps.ControlPosition.TOP_RIGHT].push(locationButton);
                
                locationButton.addEventListener('click', () => {
                    // Request location permission and start tracking
                    if (watchId === null) {
                        watchId = navigator.geolocation.watchPosition(
                            (position) => {
                                const userPos = {
                                    lat: position.coords.latitude,
                                    lng: position.coords.longitude
                                };
                                
                                // Update or create user location marker
                                if (userLocationMarker) {
                                    userLocationMarker.setPosition(userPos);
                                } else {
                                    userLocationMarker = new google.maps.Marker({
                                        position: userPos,
                                        map: map,
                                        title: '您的位置',
                                        icon: {
                                            path: google.maps.SymbolPath.CIRCLE,
                                            scale: 10,
                                            fillColor: '#4285F4',
                                            fillOpacity: 1,
                                            strokeColor: '#ffffff',
                                            strokeWeight: 2
                                        },
                                        zIndex: 999
                                    });
                                    
                                    // Add pulsing animation effect
                                    const pulsingCircle = new google.maps.Circle({
                                        strokeColor: '#4285F4',
                                        strokeOpacity: 0.8,
                                        strokeWeight: 2,
                                        fillColor: '#4285F4',
                                        fillOpacity: 0.35,
                                        map: map,
                                        center: userPos,
                                        radius: 20
                                    });
                                    
                                    // Update pulsing circle position when marker moves
                                    google.maps.event.addListener(userLocationMarker, 'position_changed', function() {
                                        pulsingCircle.setCenter(userLocationMarker.getPosition());
                                    });
                                }
                                
                                // Center map on user location first time
                                if (locationButton.textContent === '📍 显示我的位置') {
                                    map.setCenter(userPos);
                                    map.setZoom(15);
                                    locationButton.textContent = '📍 停止追踪';
                                }
                            },
                            (error) => {
                                handleLocationError(true, map.getCenter(), error);
                            },
                            {
                                enableHighAccuracy: true,
                                timeout: 5000,
                                maximumAge: 0
                            }
                        );
                    } else {
                        // Stop tracking
                        navigator.geolocation.clearWatch(watchId);
                        watchId = null;
                        locationButton.textContent = '📍 显示我的位置';
                        
                        // Optionally remove the marker
                        if (userLocationMarker) {
                            userLocationMarker.setMap(null);
                            userLocationMarker = null;
                        }
                    }
                });
            }
        }
        
        function handleLocationError(browserHasGeolocation, pos, error) {
            const errorMessage = browserHasGeolocation
                ? `位置服务错误: ${error.message}`
                : '您的浏览器不支持地理位置服务。';
            
            const infoWindow = new google.maps.InfoWindow({
                content: errorMessage,
                position: pos
            });
            
            infoWindow.open(map);
        }
        
        // Add subtle flow direction arrows
        function addFlowArrows(map, routePoints) {
            const arrowSymbol = {
                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                strokeColor: '#4285F4',
                strokeWeight: 2,
                strokeOpacity: 0.8,
                scale: 4
            };
            
            // Add arrows at regular intervals along the route
            for (let i = 0; i < routePoints.length - 1; i += 3) { // Every 3rd point to avoid clutter
                const startPoint = routePoints[i];
                const endPoint = routePoints[i + 1];
                
                // Calculate midpoint for arrow placement
                const midLat = (startPoint.lat + endPoint.lat) / 2;
                const midLng = (startPoint.lng + endPoint.lng) / 2;
                
                // Create arrow polyline
                const arrowLine = new google.maps.Polyline({
                    path: [startPoint, endPoint],
                    strokeOpacity: 0, // Invisible line
                    icons: [{
                        icon: arrowSymbol,
                        offset: '50%' // Place arrow at midpoint
                    }],
                    map: map
                });
            }
        }
    </script>
    
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD34rogilDRerCIr256FNHPMxd8phKmgcg&libraries=geometry&callback=initMap"></script>

</body>
</html>
